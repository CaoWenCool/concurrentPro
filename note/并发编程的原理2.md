# 并发编程原理2
## synchronized 的使用
### synchronized 的三种应用方式
1 修饰实例的方法，作用于当前实例加锁，进入同步代码前要获得当前的实例的锁。
2 静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁。
3 修改代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。

### synchronized 括号后面的对象
synchronized 括号后面的对象是一把锁，在java中任意一个对象都可以成为锁，简单来说，我们把object比喻是一个key，拥有这个key的线程才能
执行这个方法，拿到这个key以后在执行方法过程中，这个key是随身携带的，并且只有一把，如果后续的线程想访问当前方法，因为没有key所以不能
访问只能在门口等着，等之前的线程把key放回去。所以,synchronized 锁定的对象必须是同一个，如果是不同对象，就意味着不同的房间的钥匙，
对于访问者来说是没有任何影响的。  
### synchronized 的字节码指令
通过 javap -v 来查看对应代码的字节码指令，对于同步块的实现使用了moniorenter 和 monitorexit指令，前面我们在将JMM的时候，提到过这个
指令，他们隐式的执行了Lock和Unlock操作，用于提供原子性保证。  
monitorenter 指令插入到同步代码块开始的位置，monitorexit指令插入到同步代码块结束的位置，jvm需要保证每个monitorenter都有一个
monitorexit对应。  
这两个指令，本质上都是对一个对象的监视器 monitor 进行获取，这个过程是排他的，也就是说同一时刻只能有一个线程获取到 synchronized 
所保护的对象的监视器。  
线程执行到 monitorenter 指令时，会尝试获取对象所对应的monitor所有权，也就是尝试获取对象的锁，而执行 monitorexit ,就是释放
monitor 的所有权。  

### synchronized的锁的原理  
jdk1.6以后对synchronized锁进行了优化，包含偏向锁，轻量级锁、重量级锁，在了解synchronized 锁之前，我们需要了解两个重要的概念，
一个对象头，一个是monitor  
#### java对象头
在HotSpot虚拟机中，对象在内存中的布局分为三块区域，对象头，实例数据，和对象填充，java 对象头是实现synchronized 的锁对象的基础，
一般而言，synchronized 使用的锁对象是存储在java对象头里，它的轻量级锁和偏向锁关键。  
Mark Word
Mark Word 用于存储对象自身的运行时数据，如哈希吗（HashCode）、GC分代年龄、锁状态标志、线程持有的锁，偏爱你过线程ID
、偏向时间戳等。java  对象头一般占有两个机器码（在32位虚拟机中，1个机器码等于4个字节，也就是32bit）  

## synchronized 的锁升级和获取过程  
锁的级别从低到高逐步升级，无锁-》偏向锁-》轻量级锁-》重量级锁  

#### 自旋锁（CAS）  
自旋锁就是让不满足条件的线程等待一段时间，而不是立即挂起，看持有锁的线程是否能够满足很快释放锁。  
虽然它通过占用处理器的时间来避免线程切换带来的开销，但是如果持有锁的线程不能在很快释放锁，那么自旋的线程就会浪费
处理器的资源，因为它不会做任何有意义的工作。所以，自旋等待的时间或者次数是有一个限度的，如果自旋超过了定义的时间
仍然没有获取到锁，则该线程应该被挂起。  

#### 偏向锁  
大多数情况下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。
当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时
不需要进行CAS操作来加锁和解锁，只需要简单地测试一下对象头的Mark World 里是否存储着指向锁的标识是否设置成1,
（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。  

### 轻量级锁
引入轻量级锁的主要目的是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥产生的性能消耗。当关闭偏向锁
功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁。  

### 重量级锁
重量级锁通过对象内部的监视器实现，其中monitor 的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的
切换需要从用户态到内核态的切换，切换成本非常高。  
在hotspot虚拟机中，通过ObjectMonitor类实现monitor。它的锁的获取过程的体现会简单很多。  

## Wait 和 notify
wait 和 notify 使用让线程进入等待状态，以及得到线程唤醒的两个操作。  

### wait 和 notify的原理
调用wait方法，首先会获取监视器锁，获得成功以后，会让当前线程进入等待状态进入等待队列并且释放锁，然后当其他线程
调用notify 或者 notifyall 以后，会选择从等待队列中唤醒任意一个线程，而执行完notify方法以后，并不会立马唤醒线程
，原因是当前的线程仍然持有这把锁，处于等待状态的线程无法获得锁。必须要等到当前的线程执行完monitorexit指令以后，
也就是锁被释放以后，处于等待队列中的线程就可以开始竞争锁了。 

### wait 和 notify 为什么需要在synchronized 里面
wait方法的语义有两个，一个是释放当前的对象锁，另一个是使得当前线程进入阻塞队列，而这些操作都和监视器是相关的，
所以wait必须要获得一个监视器锁  
而对于notify来说也是一样的，它是唤醒一个线程，既然要去唤醒，首先需要知道他在哪里？所以就必须要找到这个对象获取
到这个对象的锁，然后到这个对象的等待队列中去唤醒一个线程  

